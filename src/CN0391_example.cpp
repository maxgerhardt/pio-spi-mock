#include <SPI.h>
#include "CN0391.h"
#include "Communication.h"

void setup() {
  Serial.begin(9600);
  SPI.begin();
  #ifdef ARDUINO
  // not supported for now in ArduinoFake
  SPI.setDataMode(SPI_MODE3); //CPHA = CPOL = 1    MODE = 3
  #endif
  delay(1000);

  pinMode(CS_PIN, OUTPUT);

   CN0391_init();

#if(USE_RTD_CALIBRATION == YES)
   CN0391_calibration(RTD_CHANNEL);
   Serial.println(F("RTD channel calibration completed!"));
#else
   Serial.println(F("Calibration for RTD channel is disabled."));
#endif

#if(USE_TH_CALIBRATION == YES)
   CN0391_calibration(TH_CHANNEL);
   Serial.println(F("TC channel calibration completed!"));
#else
   Serial.println(F("Calibration for TC channel is disabled."));
#endif
   
}

void loop() {
        
        delay(DISPLAY_REFRESH);
        CN0391_set_data();
        Serial.println("test");
        CN0391_display_data();
}

#ifndef ARDUINO
using namespace fakeit;
const uint8_t fake_rx_data[] = {
   0xff, 0x8, 0x61, 0xff, 0x9, 0xe9, 0xff, 0x6, 0x1, 0x81, 0xff, 0x80, 0x1, 0xff, 0x0, 0x1, 0xff, 0x0, 0x1, 0xff, 
   0x0, 0x1, 0xff, 0x0, 0x0, 0x1, 0xff, 0x8, 0x61, 0xff, 0x6, 0x1, 0x81, 0xff, 0x0, 0x1, 0xff, 0x0, 0x1, 0xff, 
   0x0, 0x1, 0xff, 0x0, 0x1, 0xff, 0x0, 0x1, 0xff, 0x0, 0x5, 0x1, 0xff, 0x0, 0x23, 0xff, 0x91, 0xff, 0x81, 0xff, 
   0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 
   0x81, 0xff, 0x0, 0x0, 0x5, 0x10, 0x0, 0x80, 0x22, 0xff, 0x10, 0xf, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 
   0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 
   0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 
   0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 
   0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 
   0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 
   0x81, 0xff, 0x81, 0xff, 0x81, 0x0, 0x0, 0x0, 0x5, 0x10, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 
   0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x0, 0x0, 
   0x5, 0x10, 0x0, 0x90, 0xe, 0xff, 0x0, 0x5, 0x3, 0xff, 0x0, 0x23, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff,
   0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x81, 0xff, 0x0, 0x0, 0xff, 0xff,
   0xff, 0x0, 0x80, 0x22, 0x0, 0x10, 0xe, 0xff, 0x81, 0xff, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x90, 0xe, 0x0, 
   0x0, 0x5, 0x0, 0x0, 0x0, 0x64, 0xff, 0x85, 0xff, 0x0, 0x0, 0xff, 0xff, 0xff, 0x0, 0x80, 0x64, 0x0, 0x10,
   0x4e, 0xff, 0x81, 0xff, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x90, 0x4e, 0x0, 0x0, 0x5, 0x2, 0x0, 0x0, 0xa6, 
   0xff, 0x85, 0xff, 0x2, 0x0, 0xff, 0xff, 0xff, 0x0, 0x80, 0xa6, 0x0, 0x10, 0x8e, 0xff, 0x83, 0xff, 0x6, 
   0x0, 0x0, 0x0, 0x0, 0x0, 0x90, 0x8e, 0x0, 0x0, 0x5, 0x4, 0x0, 0x0, 0xe4, 0xff, 0x87, 0xff, 0x2, 0x0, 
   0xff, 0xff, 0xff, 0x0, 0x80, 0xe4, 0x0, 0x10, 0xce, 0xff, 0x83, 0xff, 0x6, 0x0, 0x0, 0x0, 0x0, 0x0, 
   0x90, 0xce
};
uint8_t grab_spi_fake_data(uint8_t tx) {
   static size_t i = 0;
   if(i < sizeof(fake_rx_data))
      return fake_rx_data[i++];
   else
      return 0xAB; //error
}

void prepare_mocks() {
   ArduinoFakeReset();
   When(OverloadedMethod(ArduinoFake(SPI), transfer, uint8_t(uint8_t))).AlwaysReturn(0x00);   
   When(Method(ArduinoFake(SPI), begin)).AlwaysReturn();
   When(Method(ArduinoFake(), digitalWrite)).AlwaysReturn();
   When(Method(ArduinoFake(), pinMode)).AlwaysReturn();
   When(Method(ArduinoFake(), delay)).AlwaysReturn();
   When(OverloadedMethod(ArduinoFake(Serial), begin, void(unsigned long))).AlwaysReturn();   
   When(OverloadedMethod(ArduinoFake(Serial), write, size_t(uint8_t))).Do([](char c) {
      printf("%c", c);
      return (size_t) 1;
   });
   When(OverloadedMethod(ArduinoFake(Serial), println, size_t(const __FlashStringHelper*))).AlwaysDo([](const __FlashStringHelper *ifsh) {
      printf("%s\n", (const char*) ifsh);
      return strlen((const char*)ifsh);
   });
   When(OverloadedMethod(ArduinoFake(Serial), print, size_t(const __FlashStringHelper*))).AlwaysDo([](const __FlashStringHelper *ifsh) {
      printf("%s", (const char*) ifsh);
      return strlen((const char*)ifsh);
   });
   When(OverloadedMethod(ArduinoFake(Serial), println, size_t(const char []))).AlwaysDo([](const char c[]) {
      printf("%s\n", (const char*) c);
      return strlen((const char*)c) + 1;
   });
   When(OverloadedMethod(ArduinoFake(Serial), print, size_t(int,int))).AlwaysDo([](int n, int base) {
      char buf[64] = {0};
      const char* str = itoa(n, buf, base); 
      printf("%s", str);
      return strlen((const char*)str);
   });
   When(OverloadedMethod(ArduinoFake(Serial), println, size_t(int,int))).AlwaysDo([](int n, int base) {
      char buf[64] = {0};
      const char* str = itoa(n, buf, base); 
      printf("%s\n", str);
      return strlen((const char*)str) + 1;
   });
   When(OverloadedMethod(ArduinoFake(Serial), print, size_t(unsigned char,int))).AlwaysDo([](unsigned char b, int base) {
      printf("%c", b);
      return 1;
   });
   When(OverloadedMethod(ArduinoFake(Serial), println, size_t(unsigned char,int))).AlwaysDo([](unsigned char b, int base) {
      printf("%c\n", b);
      return 2;
   });
   When(OverloadedMethod(ArduinoFake(Serial), println, size_t(double, int))).AlwaysDo([](double n, int digits) {
      char fmt[20];
      char sout[64];
      sprintf(fmt, "%%.%df", digits);
      sprintf(sout, fmt, n);
      printf("%s\n", sout);
      return strlen(sout) + 1;
   });
   When(OverloadedMethod(ArduinoFake(Serial), print, size_t(double, int))).AlwaysDo([](double n, int digits) {
      char fmt[20];
      char sout[64];
      sprintf(fmt, "%%.%df", digits);
      sprintf(sout, fmt, n);
      printf("%s", sout);
      return strlen(sout);
   });
   setbuf(stdout, NULL);  // make printf() output appear immediately instead of buffering
}

int main() {
   prepare_mocks();
   // simulate firmware
   setup();
   loop(); // one loop iteration is enough
   return 0;
}
#endif